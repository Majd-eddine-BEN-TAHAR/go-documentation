
--------------------
File: /cmd/server/main.go
--------------------
package main

import (
	"log"
	"net/http"
	"os"

	"event_booking_api/internal/app"
	"event_booking_api/internal/config"
	"event_booking_api/pkg/database"
)

func main() {
    // Load configuration
    cfg := config.LoadConfig()
    // Initialize the database and create it if it doesn't exist
    if err := database.InitDB(cfg.DatabasePath); err != nil {
        log.Fatalf("Could not set up database: %v", err)
    }
    defer database.DB.Close()

	// Initialize database schema and create tables
    database.InitDBSchema(database.DB, "./scripts")

    http.HandleFunc("/", app.Router)

    // Define the HTTP server
    httpPort := os.Getenv("PORT")
    if httpPort == "" {
        httpPort = "3000" // Default port if not specified
    }

    // Start the HTTP server
    log.Printf("Starting server on port %s", httpPort)
    if err := http.ListenAndServe(":"+httpPort, nil); err != nil {
        log.Fatalf("Error starting server: %v", err)
    }
}

----------------------------------------

--------------------
File: /internal/app/handlers/bookingHandler.go
--------------------
package handlers

import (
	"encoding/json"
	"event_booking_api/internal/app/middlewares"
	"event_booking_api/internal/app/services"
	"event_booking_api/pkg/errors"
	"net/http"
)

// - POST for creating a booking.
// - DELETE for canceling a booking.
func BookingHandler(w http.ResponseWriter,r *http.Request){
	switch r.Method {
		case http.MethodPost:
			middlewares.AuthMiddleware(handleEventBooking)(w, r)
		case http.MethodDelete:
			middlewares.AuthMiddleware(handleCancelBooking)(w,r)
		default:
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func handleEventBooking(w http.ResponseWriter,r *http.Request){
    // Extract event ID from the URL
	eventID, _ := extractEventID(r) // Error handling have been be done in the router
    
	// Extract user ID from the context (set by auth middleware)
    userID := r.Context().Value("userID").(int)

	// Validate that the event exists
    event, err := services.GetEventByID(eventID)
    if err != nil || event == nil {
        errors.HandleError(w, errors.NewAPIError(nil, "Event not found", http.StatusNotFound))
        return
    }

	// Perform the booking
	if err := services.RegisterUserForEvent(userID, eventID); err != nil {
		errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusInternalServerError))
		return
	}

	// Respond with success message
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(struct {
	 Message string `json:"message"`
	}{"Registered for event successfully"})
}
	
func handleCancelBooking(w http.ResponseWriter, r *http.Request) {
    // Extract event ID from the URL
	eventID, _ := extractEventID(r) // Error handling have been be done in the router
    
	// Extract user ID from the context (set by auth middleware)
    userID := r.Context().Value("userID").(int)

	// Check if the event exists
    event, err := services.GetEventByID(eventID)
    if err != nil || event == nil {
        errors.HandleError(w, errors.NewAPIError(nil, "Event not found", http.StatusNotFound))
        return
    }

	// Check if the user is registered for the event
    if !services.BookingExists(userID, eventID) {
		errors.HandleError(w, errors.NewAPIError(nil, "User is not registered for this event", http.StatusNotFound))
		return
    }

    // Unregister the user from the event
    if err := services.CancelBooking(userID,eventID); err != nil {
		errors.HandleError(w, errors.NewAPIError(err, "Error when deleting the booking", http.StatusInternalServerError))
		return
	};
	
    // Respond with HTTP status code 204 - No Content
	w.WriteHeader(http.StatusNoContent)
}

----------------------------------------

--------------------
File: /internal/app/handlers/eventsHandler.go
--------------------
package handlers

import (
	"encoding/json"
	"net/http"

	"event_booking_api/internal/app/middlewares"
	"event_booking_api/internal/app/models"
	"event_booking_api/internal/app/services"
	"event_booking_api/pkg/errors"
)

// - GET to fetch all events.
// - POST to create a new event (with authentication).
func EventsHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
        case http.MethodGet:
            // Fetch all events
            handleGetEvent(w, r)
        case http.MethodPost:
            middlewares.AuthMiddleware(handlePostEvent)(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func handleGetEvent(w http.ResponseWriter, r *http.Request){
    // Fetch upcoming events
    
    events, err := services.GetUpcomingEvents()
    if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusInternalServerError))
        return
    }

    // Respond with the list of events
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(events)
}

// handlePostEvent handles the event creation request.
func handlePostEvent(w http.ResponseWriter, r *http.Request) {
    var event models.Event
	
    if err := json.NewDecoder(r.Body).Decode(&event); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Invalid request body", http.StatusBadRequest))
        return
    }

    // Extract the user ID from the request context
    userID := r.Context().Value("userID").(int)

    if err := services.CreateEvent(event, userID); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusBadRequest))
        return
    }

    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(struct {
        Message string `json:"message"`
    }{"Event created successfully"})
}
----------------------------------------

--------------------
File: /internal/app/handlers/singleEventHandler.go
--------------------
package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"strings"

	"event_booking_api/internal/app/middlewares"
	"event_booking_api/internal/app/models"
	"event_booking_api/internal/app/services"
	"event_booking_api/internal/app/validations"
	"event_booking_api/pkg/errors"
)

// - GET to fetch a single event.
// - PUT to update an event (with authentication).
// - DELETE to delete an event (with authentication).
func SingleEventHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
        case http.MethodGet:
            // Fetch single event
            handleGetSingleEvent(w, r)
		case http.MethodPut:
            // update single event
			middlewares.AuthMiddleware(handlePutSingleEvent)(w, r)
				
        case http.MethodDelete:
            // delete sinle event
            middlewares.AuthMiddleware(handleDeleteSingleEvent)(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}


func handleGetSingleEvent(w http.ResponseWriter, r *http.Request){
	// extract eventID from the URL
	eventID, err := extractEventID(r)
	if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Invalid event ID", http.StatusBadRequest))
        return
    }

	// Fetch upcoming events
    event, err := services.GetEventByID(eventID)
    if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusInternalServerError))
        return
    }

    // Respond with the list of events
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(event)
}

func handlePutSingleEvent(w http.ResponseWriter, r *http.Request) {
    // Decode the incoming JSON request to the Event struct.
    var updatedEvent models.Event
    if err := json.NewDecoder(r.Body).Decode(&updatedEvent); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Invalid request body", http.StatusBadRequest))
        return
    }

	// extract eventID from the URL
	eventID, err := extractEventID(r)
	if err != nil {
		errors.HandleError(w, errors.NewAPIError(err, "Invalid event ID", http.StatusBadRequest))
		return
	}
	
    // Validate the updated event
    if err := validations.ValidateEvent(updatedEvent); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusBadRequest))
        return
    }
	
    // get the userID from the context
	userID := r.Context().Value("userID").(int)

    // Check if the event exists and if the user is the creator
    existingEvent, err := services.GetEventByID(eventID)
    if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusNotFound))
        return
    }

    if existingEvent.CreatorID != userID {
        errors.HandleError(w, errors.NewAPIError(nil, "Unauthorized to update this event", http.StatusUnauthorized))
        return
    }

    // Update the event
    if err := services.UpdateEvent(eventID, updatedEvent); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusInternalServerError))
        return
    }

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(struct {
        Message string `json:"message"`
    }{"Event updated successfully"})
}

func handleDeleteSingleEvent(w http.ResponseWriter, r *http.Request) {
    // Extract eventID from the URL
    eventID, err := extractEventID(r)
    if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Invalid event ID", http.StatusBadRequest))
        return
    }

    // Get the userID from the context
    userID := r.Context().Value("userID").(int)

    // Check if the event exists and if the user is the creator
    event, err := services.GetEventByID(eventID)
    if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Event not found", http.StatusNotFound))
        return
    }

    if event.CreatorID != userID {
        errors.HandleError(w, errors.NewAPIError(nil, "Unauthorized to delete this event", http.StatusUnauthorized))
        return
    }

    // Delete the event
    if err := services.DeleteEvent(eventID); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Error deleting event", http.StatusInternalServerError))
        return
    }

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(struct {
        Message string `json:"message"`
    }{"Event deleted successfully"})
}

// Function to extract eventID from the URL
func extractEventID(r *http.Request) (int, error) {
    path := strings.Trim(r.URL.Path, "/")
    pathSegments := strings.Split(path, "/")
    // Assuming the eventID is the second segment in the URL
    eventIdStr := pathSegments[1]
    eventID, err := strconv.Atoi(eventIdStr)
    if err != nil {
        return 0, err // Return an error if conversion fails
    }
    return eventID, nil
}
----------------------------------------

--------------------
File: /internal/app/handlers/userHandler.go
--------------------
package handlers

import (
	"encoding/json"
	"net/http"

	"event_booking_api/internal/app/models"
	"event_booking_api/internal/app/services"
	"event_booking_api/pkg/errors"
)

// RegisterHandler handles the user registration requests.
// It supports POST method to register a new user.
func RegisterHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
        case http.MethodPost:
            handlePostRegister(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

// LoginHandler handles the user login requests.
// It supports POST method to authenticate a user.
func LoginHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
        case http.MethodPost:
            handlePostLogin(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}


// handlePostRegister is the HTTP post handler for the user registration endpoint.
// It processes the user registration request and responses.
func handlePostRegister(w http.ResponseWriter, r *http.Request) {
    var user models.User

    // Decode the incoming JSON request to the User struct and put in the user variable.
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Invalid request body", http.StatusBadRequest))
        return
    }

    // Call the RegisterUser service to register the user.
    if err := services.RegisterUser(user); err != nil {
        // Pass the specific error message from the service
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusBadRequest))
        return // Stop processing and return an error if registration fails
    }

    // Respond with a success message if registration is successful.
	// Set the HTTP response status code to 201 Created.
	w.WriteHeader(http.StatusCreated)

	// Create a JSON encoder that writes to the http.ResponseWriter 'w'.
	encoder := json.NewEncoder(w)

	// Create an anonymous struct with a 'Message' field and initialize it
	// with the message indicating successful user registration.
	response := struct {
		Message string `json:"message"`
	}{"User registered successfully"}

	// Encode the 'response' struct into JSON format and send it as the
	// HTTP response body.
	encoder.Encode(response)
}


// handlePostLogin handles user login post requests
func handlePostLogin(w http.ResponseWriter, r *http.Request) {
    var creds models.Credentials 

    // Decode the incoming JSON request to the Credentials struct and put in the creds variable.
	if err := json.NewDecoder(r.Body).Decode(&creds); err != nil {
        errors.HandleError(w, errors.NewAPIError(err, "Invalid request body", http.StatusBadRequest))
        return
    }

    // Authenticate the user
	// err.Error() will add the error message returned from AuthenticateUser
    token, err := services.AuthenticateUser(creds)
    if err != nil {
        errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusUnauthorized))
        return
    }

    // Respond with JWT token if login is successful
    json.NewEncoder(w).Encode(struct {
        Token string `json:"token"`
    }{Token: token})
}
----------------------------------------

--------------------
File: /internal/app/middlewares/authMiddleware.go
--------------------
package middlewares

import (
	"context"
	"net/http"
	"strings"

	"event_booking_api/pkg/auth"
	"event_booking_api/pkg/errors"
)

// AuthMiddleware is a middleware that checks if the user is authenticated
func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Step 1: Extract the token from the Authorization header
        tokenHeader := r.Header.Get("Authorization")

        // Step 2: Check if the Authorization header is empty
        if tokenHeader == "" {
            // If empty, respond with a missing token error (401 Unauthorized)
            errors.HandleError(w, errors.NewAPIError(nil, "Missing auth token", http.StatusUnauthorized))
            return
        }

        // Step 3: Extract the token from "Bearer " prefix
        token := strings.TrimPrefix(tokenHeader, "Bearer ")
        if token == tokenHeader {
            // Respond with an invalid token format error (401 Unauthorized)
            errors.HandleError(w, errors.NewAPIError(nil, "Invalid token format", http.StatusUnauthorized))
            return
        }

        // Step 4: Validate the token and get the user ID
        userID, err := auth.ValidateToken(token)
        if err != nil {
            // If validation fails (e.g., invalid or expired token), respond with an error (401 Unauthorized)
            errors.HandleError(w, errors.NewAPIError(err, err.Error(), http.StatusUnauthorized))
            return
        }

        // Step 5: Add the userID to the request context to use it within the request.
        ctx := context.WithValue(r.Context(), "userID", userID)
        r = r.WithContext(ctx)

        // Step 6: Token is valid, proceed with the request
        next.ServeHTTP(w, r)
    }
}
----------------------------------------

--------------------
File: /internal/app/models/booking.go
--------------------
package models

import "time"

type Booking struct {
    ID        int       `json:"id"`
    UserID    int       `json:"user_id"`
    EventID   int       `json:"event_id"`
    Timestamp time.Time `json:"booking_time"`
}
----------------------------------------

--------------------
File: /internal/app/models/credentials.go
--------------------
package models

// Credentials used for login
type Credentials struct {
    Username string `json:"username"`
    Password string `json:"password"`
}


----------------------------------------

--------------------
File: /internal/app/models/event.go
--------------------
package models

import "time"

// Event represents the structure for an event.
type Event struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Location    string    `json:"location"`
    StartTime   time.Time `json:"start_time"`
    EndTime     time.Time `json:"end_time"`
    CreatorID int         `json:"creator_id"` // Reference to the user who created the event.
}

----------------------------------------

--------------------
File: /internal/app/models/user.go
--------------------
package models

// User represents the user model in our application.
// It contains the username, password, and email of the user.
type User struct {
	ID       int  
	Username string 
	Password string
	Email	 string
}
----------------------------------------

--------------------
File: /internal/app/router.go
--------------------
package app

import (
	"net/http"
	"strconv"
	"strings"

	"event_booking_api/internal/app/handlers"
	"event_booking_api/pkg/errors"
)

/*     /login 						POST 							*/
/*     /register 					POST 							*/
/*     /events 						GET 							*/
/*     /events 						POST    => Auth required 		*/
/*     /events/<id> 				GET 							*/
/*     /events/<id> 				PUT   	=> Auth required 		*/
/*     /events/<id> 				DELETE  => Auth required 		*/
/*     /events/<id>/register 		POST 	=> Auth required 	 	*/
/*     /events/<id>/register 		DELETE 	=> Auth required 		*/

func Router(w http.ResponseWriter, r *http.Request) {
    path := strings.Trim(r.URL.Path, "/")
    pathSegments := strings.Split(path, "/")

    switch pathSegments[0] {
		case "login":
			handlers.LoginHandler(w, r)
			return
		case "register":
			handlers.RegisterHandler(w, r)
			return
		case "events":
			if len(pathSegments) > 1 && !isValidEventID(pathSegments[1]) {
				errors.HandleError(w, errors.NewAPIError(nil, "Invalid ID. Must be an integer.", http.StatusBadRequest))
                return
			}

			switch {
				case len(pathSegments) == 1:
					handlers.EventsHandler(w, r)
				case len(pathSegments) == 2:
					handlers.SingleEventHandler(w, r)
				case len(pathSegments) == 3 && pathSegments[2] == "register":
					handlers.BookingHandler(w, r)
				default:
					http.NotFound(w, r)
			}
			return 
    }

    // If no route matches, return 404 Not Found
    http.NotFound(w, r)
}

func isValidEventID(eventIDStr string) bool {
    _, err := strconv.Atoi(eventIDStr)
    return err == nil
}

----------------------------------------

--------------------
File: /internal/app/services/bookingService.go
--------------------
package services

import (
	"errors"

	"database/sql"
	"event_booking_api/pkg/database"
)

// RegisterUserForEvent registers a user for a specific event.
func RegisterUserForEvent(userID, eventID int) error {
    // Check if the booking already exists to prevent duplicates.
    if BookingExists(userID, eventID) {
        return errors.New("user already registered for this event")
    }

    // Insert new booking
    query := `INSERT INTO bookings (user_id, event_id) VALUES (?, ?)`
    _, err := database.DB.Exec(query, userID, eventID)
    if err != nil {
		// Return an error if the insertion fails.
        return errors.New("failed to insert new booking into the database")
    }

    return nil
}

// BookingExists checks if a booking already exists for a given user and event.
func BookingExists(userID, eventID int) bool {
    var id int
    query := `SELECT id FROM bookings WHERE user_id = ? AND event_id = ?`
    err := database.DB.QueryRow(query, userID, eventID).Scan(&id)
    
	// Return true if a record is found, false if not.
    return err != sql.ErrNoRows
}


func CancelBooking(userID, eventID int) error {
	query := `DELETE FROM bookings WHERE user_id = ? and event_id = ?`
    _, err := database.DB.Exec(query, userID, eventID)
    return err
}




----------------------------------------

--------------------
File: /internal/app/services/eventService.go
--------------------
package services

import (
	"event_booking_api/internal/app/models"
	"event_booking_api/internal/app/validations"

	"event_booking_api/pkg/database"
)

// CreateEvent handles the creation of a new event in the database.
func CreateEvent(event models.Event, userID int) error {
	// Validate the event data before inserting into the database.
    if err := validations.ValidateEvent(event); err != nil {
        return err
    }

	query := `INSERT INTO events (title, description, location, start_time, end_time, creator_id)
	VALUES (?, ?, ?, ?, ?, ?)`
	_, err := database.DB.Exec(query, event.Title, event.Description, event.Location, event.StartTime, event.EndTime, userID)
	if err != nil {
		return err
	}

	return nil
}

// GetUpcomingEvents retrieves all events with a start time greater than the current time.
func GetUpcomingEvents() ([]models.Event, error) {
    var events []models.Event

    // Query to select events with start_time greater than the current time
    query := `SELECT id, title, description, location, start_time, end_time, creator_id FROM events WHERE start_time > CURRENT_TIMESTAMP`
    rows, err := database.DB.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    // Iterating over the query results and appending them to the events slice.
    for rows.Next() {
        var event models.Event
        if err := rows.Scan(&event.ID, &event.Title, &event.Description, &event.Location, &event.StartTime, &event.EndTime, &event.CreatorID); err != nil {
            return nil, err
        }
        events = append(events, event)
    }

        // Checking for any errors occurred during iteration on rows.
    if err := rows.Err(); err != nil {
        return nil, err
    }

    return events, nil
}

// GetEventByID retrieves an event by its ID from the database.
func GetEventByID(eventID int) (*models.Event, error) {
    var event models.Event

    // SQL query to retrieve the event data
    query := `SELECT * FROM events WHERE id = ?`
    
    // Executing the query with the event ID
    row := database.DB.QueryRow(query, eventID)

    // Scanning the query result into the event struct.
    err := row.Scan(&event.ID, &event.Title, &event.Description, &event.Location, &event.StartTime, &event.EndTime, &event.CreatorID)
    if err != nil {
        // Return the error if any occurred during query execution or putting values in the row
        return nil, err
    }

    // Return the retrieved event and nil error
    return &event, nil
}

// UpdateEvent updates an existing event's details in the database.
func UpdateEvent(id int, event models.Event) error {
    query := `UPDATE events SET title = ?, description = ?, location = ?, start_time = ?, end_time = ? WHERE id = ?`
    _, err := database.DB.Exec(query, event.Title, event.Description, event.Location, event.StartTime, event.EndTime, id)
    return err

}

// DeleteEvent deletes an event from the database by its ID.
func DeleteEvent(eventID int) error {
    query := `DELETE FROM events WHERE id = ?`
    _, err := database.DB.Exec(query, eventID)
    return err
}

----------------------------------------

--------------------
File: /internal/app/services/userService.go
--------------------
package services

import (
	"errors"
	"event_booking_api/internal/app/models"
	"event_booking_api/internal/app/validations"
	"event_booking_api/pkg/auth"
	"event_booking_api/pkg/database"

	"golang.org/x/crypto/bcrypt"
)

// RegisterUser handles the registration of a new user.
// It hashes the user's password and stores the user's details in the database.
func RegisterUser(user models.User) error {
	// Validate user input
    if err := validations.ValidateUser(user); err != nil {
        return err
    }

    // Check if the email already exists in the database
    var emailCount int
    err := database.DB.QueryRow("SELECT COUNT(*) FROM users WHERE email = ?", user.Email).Scan(&emailCount)
    if err != nil {
        return err
    }

    if emailCount > 0 {
        return errors.New("email already exists")
    }

    // Check if the username already exists in the database
    var usernameCount int
    err = database.DB.QueryRow("SELECT COUNT(*) FROM users WHERE username = ?", user.Username).Scan(&usernameCount)
    if err != nil {
        return err
    }

    if usernameCount > 0 {
        return errors.New("username already exists")
    }

    // Hash the user's password using bcrypt.
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
    if err != nil {
        return err // Return error if password hashing fails
    }

    // Insert the new user into the database.
    // The hashed password is stored, not the plain one.
    _, err = database.DB.Exec("INSERT INTO users (username, password, email) VALUES (?, ?, ?)",
        user.Username, string(hashedPassword), user.Email)
    return err // Return error if the database operation fails
}


// AuthenticateUser checks the credentials and returns a JWT token if they are valid
func AuthenticateUser(creds models.Credentials) (string, error) {
    
	// Validate user input
	if err := validations.ValidateLogin(creds); err != nil {
		return "", err
	}

	// Retrieve user from database by username
    var user models.User
    err := database.DB.QueryRow("SELECT id, username, password FROM users WHERE username = ?", creds.Username).Scan(&user.ID,&user.Username, &user.Password)
    if err != nil {
        return "", errors.New("invalid username or password")
    }

    // Compare the provided password with the stored hashed password
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(creds.Password)); err != nil {
        return "", errors.New("invalid username or password")
    }

    // Generate and return a JWT token
    token, err := auth.GenerateToken(user.ID)
    if err != nil {
        return "", err
    }

    return token, nil
}
----------------------------------------

--------------------
File: /internal/app/validations/commonValidation.go
--------------------
package validations

import "regexp"

// isValidEmail checks if the email is valid
func isValidEmail(email string) bool {
    regex := regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)
    return regex.MatchString(email)
}
----------------------------------------

--------------------
File: /internal/app/validations/eventValidation.go
--------------------
package validations

import (
	"errors"
	"event_booking_api/internal/app/models"
	"time"
)

// ValidateEvent checks the validity of the event data.
func ValidateEvent(event models.Event) error {
    if len(event.Title) < 4 || len(event.Description) < 10 {
        return errors.New("title must be at least 4 characters and description at least 10 characters long")
    }

    // Check if the location is a non-empty string
    if len(event.Location) == 0 {
        return errors.New("event location must be specified")
    }

    // Validate that the start time is before the end time
    if !event.StartTime.Before(event.EndTime) {
        return errors.New("start time must be before end time")
    }

    // Ensure the event start time is not in the past
    if event.StartTime.Before(time.Now()) {
        return errors.New("event start time must be in the future")
    }

    return nil
}
----------------------------------------

--------------------
File: /internal/app/validations/userValidation.go
--------------------
package validations

import (
	"errors"

	"event_booking_api/internal/app/models"
)

// ValidateUser validates the user's data
func ValidateUser(user models.User) error {
    if len(user.Username) < 4 || len(user.Password) < 4 {
        return errors.New("username and password must be at least 4 characters long")
    }

    if !isValidEmail(user.Email) {
        return errors.New("invalid email address")
    }

    return nil
}


// ValidateLogin validates the login credentials
func ValidateLogin(creds models.Credentials) error {
    // Check if username and password are provided and meet basic length requirements
    if len(creds.Username) < 4 || len(creds.Password) < 4 {
        return errors.New("username and password must be at least 4 characters long")
    }

    // Add any other specific login validations here if needed

    return nil
}

----------------------------------------

--------------------
File: /internal/config/config.go
--------------------
package config

import (
	"fmt"
	"log"
	"os"

	"github.com/joho/godotenv"
)

// Config struct to hold application configuration
type Config struct {
    DatabasePath string
    JWTSecret    string
}

// LoadConfig loads application configurations from .env file
func LoadConfig() *Config {
    // Load environment variables from .env file
    err := godotenv.Load()
    fmt.Println(err)
    if err != nil {
        log.Fatal("Error loading .env file")
    }
    // Return the configurations as a Config struct
    return &Config{
        DatabasePath: os.Getenv("DATABASE_PATH"), // Database path from .env
        JWTSecret:    os.Getenv("JWT_SECRET"),    // JWT secret key from .env
    }
}
----------------------------------------

--------------------
File: /pkg/auth/jwt.go
--------------------
package auth

import (
	"errors"
	"net/http"
	"os" // Used for accessing environment variables
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
)

// jwtKey is the secret key used for signing JWT tokens. It's fetched from an environment variable.
var jwtKey = []byte(os.Getenv("JWT_SECRET"))

// Claims struct represents the data embedded in the JWT token.
// In this case, we're storing the user's ID.
type Claims struct {
    UserID int `json:"user_id"`
    jwt.StandardClaims
}

// GenerateToken creates a JWT token with the user's ID.
func GenerateToken(userID int) (string, error) {
    // Token expiration time is set to 1 hour from now.
    expirationTime := time.Now().Add(1 * time.Hour)

    // Creating JWT claims including user ID and expiration time.
    claims := &Claims{
        UserID: userID,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
        },
    }

    // Creating a new token with the provided claims.
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

    // Signing the token with the secret key.
	tokenString, err := token.SignedString(jwtKey)
    return tokenString, err
}

// ValidateToken checks the validity of a JWT token and returns the user ID if valid.
func ValidateToken(tokenString string) (int, error) {
    claims := &Claims{}

    // Parsing and validating the token. The key function provides the signing key for verification.
    // ParseWithClaims is a function from the JWT package in Go. It's used to parse a JWT token and validate it.
    // It takes the token string, a claims object where the data from the token will be stored, and a function to retrieve the signing key for verification. The function then parses the token, validates it, and fills the claims object with the token's data.
    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return jwtKey, nil
    })
    if err != nil {
        return 0, err
    }

    // Verifying that the token is valid.
    if !token.Valid {
        return 0, errors.New("invalid token")
    }

    // Returning the user ID from the token's claims.
    return claims.UserID, nil
}


// GetUserFromToken extracts the user ID from the JWT token provided in the request.
func GetUserFromToken(r *http.Request) (int, error) {
    // Extract the token from the Authorization header
    tokenHeader := r.Header.Get("Authorization")

    // Strip the "Bearer " prefix from the token
    token := strings.TrimPrefix(tokenHeader, "Bearer ")
    if token == tokenHeader {
        return 0, errors.New("no token found")
    }

    // Validate the token and extract the claims
    userID, err := ValidateToken(token)
    if err != nil {
        return 0, err
    }

    return userID, nil
}
----------------------------------------

--------------------
File: /pkg/database/db.go
--------------------
package database

import (
	"database/sql"
	"os"

	// In Go, when an underscore _ is used before an import statement, it indicates that the package is being imported for its side-effects only, and you won't directly use any functions, types, or variables from that package. This is known as a "blank import."
	// For github.com/mattn/go-sqlite3, the underscore is used because this package registers itself with the database/sql package when imported. The driver (go-sqlite3) is necessary for the sql package to work with SQLite databases, but you don't directly call any functions from go-sqlite3.
	_ "github.com/mattn/go-sqlite3" // Import SQLite driver
)

// DB is a global variable to hold the database connection
var DB *sql.DB

// InitDB initializes the database connection using a given dataSourceName
func InitDB(dataSourceName string) error {
    // Check if the database file exists
    if _, err := os.Stat(dataSourceName); os.IsNotExist(err) {
        file, err := os.Create(dataSourceName) // Create the file if it does not exist
        if err != nil {
            return err
        }
        file.Close() // Close the file after creating it
    }
    
    var err error
    // Open a database connection with the SQLite driver and the provided dataSourceName
    DB, err = sql.Open("sqlite3", dataSourceName)
    if err != nil {
        return err
    }
    // Ping the database to verify the connection is established
    if err = DB.Ping(); err != nil {
        return err
    }
    return nil
}

----------------------------------------

--------------------
File: /pkg/database/dbInit.go
--------------------
package database

import (
	"database/sql"
	"log"
	"os"
	"path/filepath"
)

// InitDBSchema initializes the database schema using SQL scripts
func InitDBSchema(db *sql.DB, scriptsPath string) {
    // Read SQL file
    path := filepath.Join(scriptsPath, "init_db.sql")
    content, err := os.ReadFile(path)
    if err != nil {
        log.Fatalf("Error reading SQL file: %v", err)
    }

    // Execute SQL commands
    _, err = db.Exec(string(content))
    if err != nil {
        log.Fatalf("Error executing SQL script: %v", err)
    }

    log.Println("Database schema initialized successfully")
}
----------------------------------------

--------------------
File: /pkg/errors/errors.go
--------------------
package errors

import (
	"encoding/json"
	"log"
	"net/http"
)

// APIError represents an error with an additional status code
type APIError struct {
    Error   error
    Message string
    Code    int
}

// NewAPIError creates a new APIError
func NewAPIError(err error, message string, code int) *APIError {
    return &APIError{
        Error:   err,
        Message: message,
        Code:    code,
    }
}

// HandleError handles the error by logging it and sending an appropriate response to the client
func HandleError(w http.ResponseWriter, err *APIError) {
    log.Printf("Error: %v", err.Error) // Log the error

    // Send a JSON response with the error message and status code
    w.WriteHeader(err.Code)
    json.NewEncoder(w).Encode(struct {
        Message string `json:"message"`
    }{
        Message: err.Message,
    })
}
----------------------------------------
